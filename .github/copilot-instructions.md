# Copilot Instructions: LLM WASM Sandbox

## Project Overview

This project provides a **production-grade security sandbox** for executing **untrusted Python code generated by LLMs** using WebAssembly (WASM) and WASI. The architecture uses **Wasmtime** (Python host) to run **CPython compiled to WASM** (WLR AIO binary) with strict capability-based isolation.

**Core Security Model**: Multi-layered defense combining WASM memory safety, WASI capability-based I/O, deterministic execution limits (fuel), and memory caps. Designed for enterprise scenarios requiring strong isolation and auditability.

## Architecture & Key Components

### Modern Architecture (Post-Refactor)

The project now follows an enterprise-grade, type-safe architecture:

```
sandbox/
  core/                         # Type-safe foundation
    __init__.py
    models.py                   # Pydantic: ExecutionPolicy, SandboxResult, RuntimeType
    base.py                     # BaseSandbox ABC
    errors.py                   # PolicyValidationError, SandboxExecutionError
    logging.py                  # SandboxLogger (structured events)
    factory.py                  # create_sandbox() factory
  
  runtimes/                     # Runtime-specific implementations
    python/
      __init__.py
      sandbox.py                # PythonSandbox(BaseSandbox)
  
  # Legacy modules (refactored, backwards compatible)
  host.py                       # Low-level Wasmtime/WASI wrapper
  policies.py                   # load_policy() → ExecutionPolicy
  runner.py                     # Legacy execute() for backwards compat
  utils.py                      # Unchanged
  vendor.py                     # Unchanged
```

### Three-Layer Structure

1. **Core Layer** (`sandbox/core/`): Type-safe models, abstractions, and structured logging
   - `ExecutionPolicy`: Pydantic model with validated resource limits
   - `SandboxResult`: Typed execution results with metrics
   - `BaseSandbox`: Abstract interface for multi-runtime support
   - `SandboxLogger`: Structured event logging (execution.start, execution.complete)

2. **Runtime Layer** (`sandbox/runtimes/`): Runtime-specific sandbox implementations
   - `PythonSandbox`: CPython WASM execution with fuel/memory limits
   - Future: `JavaScriptSandbox` for JavaScript runtime

3. **Host Layer** (`sandbox/host.py`): Low-level Wasmtime/WASI configuration
   - WASM binary loading and execution
   - Fuel budgeting and memory limiting
   - Capability-based filesystem isolation (WASI preopens)

### Critical Files (per `WASM_SANDBOX.md`)
- `bin/python.wasm`: WLR AIO CPython-for-WASI binary (downloaded, not source-controlled)
- `config/policy.toml`: Tunable execution policy (fuel, memory, preopens, env vars)
- `workspace/`: Preopened directory visible to guest as `/app` (WASI capability mount point)
- `tests/`: Comprehensive test suite (security boundaries, type validation, API contracts)
- `sandbox/core/models.py`: Pydantic models for type-safe configuration and results
- `sandbox/runtimes/python/sandbox.py`: Main execution logic for Python runtime

## Developer Workflow

### Setup & Dependencies
```powershell
# Initial setup (uv creates venv automatically)
uv sync

# Fetch WASM binary (bash script - adapt for Windows or use Git Bash/WSL)
./scripts/fetch_wlr_python.sh

# Run commands with uv
uv run python -c "from sandbox import create_sandbox, RuntimeType; sandbox = create_sandbox(runtime=RuntimeType.PYTHON); print(sandbox.execute('print(42)').stdout)"
```

**Key dependency**: `wasmtime==38.*` (pin major/minor - API changes frequently). Python 3.11+ for `tomllib`; use `tomli` for older versions.

**Using uv**: This project uses [uv](https://docs.astral.sh/uv/) for fast, reliable Python package management. `uv sync` reads `pyproject.toml` and creates a locked environment. Use `uv run` to execute commands in the managed environment, or `uv add <package>` to add dependencies.

### Running Untrusted Code

**Typed API:**
```python
from sandbox import create_sandbox, RuntimeType
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
result = sandbox.execute("print('Hello from WASM')")
# Returns: SandboxResult (Pydantic model) with typed fields
print(result.stdout, result.fuel_consumed, result.success)
```

**With Custom Policy:**
```python
from sandbox import create_sandbox, ExecutionPolicy, RuntimeType

policy = ExecutionPolicy(
    fuel_budget=1_000_000_000,      # Validated > 0
    memory_bytes=64 * 1024 * 1024,  # Validated > 0
    env={"API_KEY": "secret"}       # Whitelist pattern
)
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
result = sandbox.execute(code)
```

### Testing Security Boundaries
Run `tests/test_*.py` to verify:
- **Fuel exhaustion**: `test_infinite_loop.py` → OutOfFuel trap
- **Filesystem isolation**: `test_fs_escape.py` → WASI denies paths outside `/app`
- **Memory limits**: `test_memory_blowup.py` → hits configured cap

## Project-Specific Patterns

### WASI Capability-Based Isolation
- **Preopen pattern**: `WasiConfig.preopen_dir(host_path, guest_mount_path)` grants least-privilege filesystem access
- Guest sees **only** `/app` (mapped to `workspace/` on host) - no ambient filesystem, no `..` escapes
- Absolute paths or attempts to traverse outside preopens fail with `not-permitted`

### Fuel-Based Deterministic Interruption
```python
# In host.py
cfg.consume_fuel = True
store.add_fuel(policy["fuel_budget"])  # e.g., 400_000_000 instructions
# Exhaustion → wasmtime.Trap (OutOfFuel)
```
**Limitation**: Fuel cannot preempt **blocking WASI host calls** (e.g., sleep) - use OS-level timeouts for hard stops.

### Memory Limiting
```python
store.set_limits(memory_size=policy["memory_bytes"])  # e.g., 64 MB
```
Restricts guest linear memory growth. Check `wasmtime-py` version compatibility.

### Stdio Capture Pattern
```python
# WASI redirects stdout/stderr to temp files
wasi.stdout_file = "stdout.log"
wasi.stderr_file = "stderr.log"
# Read with size caps to prevent DoS
```

## Code Conventions

### Imports & Compatibility
- Use `from __future__ import annotations` for forward references
- Conditional TOML parser: `tomllib` (3.11+) vs `tomli` (earlier)
- Type hints required: `def run_untrusted_python(wasm_path: str = "bin/python.wasm") -> SandboxResult`

### Error Handling
- Catch `wasmtime.Trap` for fuel exhaustion / WASM errors
- Use `try/except` with specific exceptions (avoid bare `except`)
- Malicious code failures are **expected** - capture in stderr, don't re-raise

### Policy Defaults
Centralized in `sandbox/policies.py` and `sandbox/core/models.py`:
- Fuel: 2B instructions (default in ExecutionPolicy)
- Memory: 128 MB (default in ExecutionPolicy)
- Stdout/stderr: 2 MB / 1 MB caps (default in ExecutionPolicy)
- Argv: `["python", "/app/user_code.py", "-X", "utf8"]`

**Custom Policy with Validation:**
```python
from sandbox import create_sandbox, ExecutionPolicy, RuntimeType

policy = ExecutionPolicy(
    fuel_budget=1_000_000_000,      # Validated > 0
    memory_bytes=64 * 1024 * 1024,  # Validated > 0
    env={"API_KEY": "secret"}       # Whitelist pattern
)
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
```

Merge user-provided `policy.toml` with defaults using dict union (`|` operator) in `load_policy()`.

## Integration Points

### LLM Pipeline Flow
1. LLM generates Python code (untrusted)
2. Create sandbox: `sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=custom_policy)`
3. Execute code: `result = sandbox.execute(code)` → returns typed `SandboxResult`
4. Collect metrics (`result.fuel_consumed`, `result.duration_seconds`) + output for LLM feedback loop
5. Use structured logging via `SandboxLogger` for observability

**Example Integration:**
```python
from sandbox import create_sandbox, ExecutionPolicy, RuntimeType

policy = ExecutionPolicy(fuel_budget=500_000_000, memory_bytes=32*1024*1024)
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)

llm_code = generate_code_from_llm(prompt)
result = sandbox.execute(llm_code)

if not result.success:
    feedback = f"Execution failed: {result.stderr}"
elif result.fuel_consumed > 400_000_000:
    feedback = "Code too complex, simplify"
else:
    feedback = f"Success: {result.stdout}"
```

### External Dependencies
- **WLR Python binary**: Update `scripts/fetch_wlr_python.sh` with latest [release tag](https://github.com/webassemblylabs/webassembly-language-runtimes/releases)
- **Wasmtime versions**: Monthly releases - test before upgrading, check [changelog](https://github.com/bytecodealliance/wasmtime-py/releases)

### Defense-in-Depth (Production Hardening)
Per `WASM_SANDBOX.md` section 9:
- **WASM layer** (this project): Memory safety, capability isolation, fuel limits
- **OS layer** (future): Run sandbox in separate process with OS timeouts, use containers/cgroups for multi-tenant deployment
- **No networking**: WASI baseline doesn't expose sockets unless explicitly added

## Commands & Scripts

### Fetch WASM Binary
```bash
./scripts/fetch_wlr_python.sh
# Downloads python.wasm to bin/ - ~50-100 MB AIO artifact
```

### Run Tests (Malicious Samples)
```powershell
uv run python tests/test_infinite_loop.py    # Should trap with OutOfFuel
uv run python tests/test_fs_escape.py        # Should fail to read /etc/passwd
uv run python tests/test_memory_blowup.py    # Should hit memory cap
```

### Quick REPL Test
```powershell
uv run python -c "from sandbox import create_sandbox, RuntimeType; sandbox = create_sandbox(runtime=RuntimeType.PYTHON); result = sandbox.execute('import os; print(os.getenv(\"DEMO_GREETING\"))'); print(result.stdout)"
```

## Windows-Specific Notes

- PowerShell is default shell - use `pwsh` conventions in terminal commands
- Bash script (`fetch_wlr_python.sh`) requires Git Bash/WSL or adapt to PowerShell `Invoke-WebRequest`
- Path separators: Use `Path` objects from `pathlib` for cross-platform compatibility
- **uv installation**: Install via `powershell -c "irm https://astral.sh/uv/install.ps1 | iex"` or `pip install uv`
- Use `uv run` prefix for all Python commands to ensure correct environment activation

## Security Considerations for AI Agents

When modifying this codebase:
1. **Never expand WASI capabilities** without explicit review (e.g., adding network access)
2. **Validate policy changes**: Lowering fuel/memory limits may break legitimate use cases; increasing may enable DoS
3. **Preopen paths must be absolute**: Relative paths can leak host info via error messages
4. **Env var whitelist**: Only expose explicitly required vars (no `os.environ` passthrough)
5. **Test malicious inputs**: Any new feature must have a corresponding `tests/test_*_attack.py`

## Known Limitations

- **Blocking host calls**: Fuel can't interrupt sleep/blocking I/O - requires OS-level timeout wrapper
- **No async support**: Current `wasmtime-py` lacks async WASI bindings (epochs feature not exposed)
- **Single-threaded**: WASM guest is single-threaded (CPython GIL doesn't matter here)
- **No networking**: By design - extend only if required with careful capability analysis
