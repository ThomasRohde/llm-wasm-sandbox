# Project Context

## Purpose
Production-grade security sandbox for executing **untrusted code generated by LLMs** using WebAssembly (WASM) and WASI. The architecture uses **Wasmtime** (Python host) to run **CPython/QuickJS compiled to WASM** with strict capability-based isolation.

**Core Security Model**: Multi-layered defense combining WASM memory safety, WASI capability-based I/O, deterministic execution limits (fuel), and memory caps. Designed for enterprise scenarios requiring strong isolation and auditability.

**Supported Runtimes**:
- **Python**: CPython 3.11 (WLR AIO binary)
- **JavaScript**: QuickJS-NG WASI binary

## Tech Stack
- **Language**: Python 3.11+ (type hints, Pydantic models)
- **Package Manager**: [uv](https://docs.astral.sh/uv/) for fast, reliable dependency management
- **WASM Runtime**: `wasmtime-py` 38.* (pinned major/minor - API changes frequently)
- **Validation**: Pydantic v2 for type-safe configuration models
- **Testing**: pytest with comprehensive security boundary tests
- **Logging**: Structured JSON logging via `SandboxLogger`
- **Config**: TOML (`tomllib` for 3.11+, `tomli` fallback)
- **WASM Binaries**:
  - CPython WASM: [WLR AIO](https://github.com/webassemblylabs/webassembly-language-runtimes/releases) (~50-100 MB)
  - QuickJS WASM: [QuickJS-NG](https://github.com/quickjs-ng/quickjs/releases) (~1.4 MB)

## Project Conventions

### Code Style
- **Type hints required**: All public functions must have return type annotations
  ```python
  def execute(code: str) -> SandboxResult:
  ```
- **Future annotations**: Use `from __future__ import annotations` for forward references
- **Pydantic models**: Use for all configuration and result types (validated at runtime)
- **Path handling**: Use `pathlib.Path` objects for cross-platform compatibility
- **Error handling**: Catch specific exceptions (`wasmtime.Trap`, `PolicyValidationError`), avoid bare `except`
- **Imports**: Group by stdlib, third-party, local; use absolute imports
- **Naming**:
  - Classes: `PascalCase` (e.g., `ExecutionPolicy`, `SandboxResult`)
  - Functions/methods: `snake_case` (e.g., `create_sandbox`, `load_policy`)
  - Constants: `UPPER_SNAKE_CASE` (e.g., `DEFAULT_FUEL_BUDGET`)
  - Private: prefix with `_` (e.g., `_validate_policy`)

### Architecture Patterns

**Three-Layer Structure**:

1. **Core Layer** (`sandbox/core/`): Type-safe foundation
   - `models.py`: Pydantic models (`ExecutionPolicy`, `SandboxResult`, `RuntimeType`)
   - `base.py`: `BaseSandbox` abstract base class
   - `errors.py`: Custom exceptions (`PolicyValidationError`, `SandboxExecutionError`)
   - `logging.py`: Structured event logging (`SandboxLogger`)
   - `factory.py`: `create_sandbox()` factory function

2. **Runtime Layer** (`sandbox/runtimes/`): Runtime-specific implementations
   - `python/sandbox.py`: `PythonSandbox(BaseSandbox)` for CPython WASM
   - `javascript/sandbox.py`: `JavaScriptSandbox(BaseSandbox)` for QuickJS WASM

3. **Host Layer** (`sandbox/host.py`): Low-level Wasmtime/WASI wrapper
   - WASM binary loading and execution
   - Fuel budgeting and memory limiting
   - Capability-based filesystem isolation (WASI preopens)

**Key Patterns**:
- **WASI Capability Isolation**: `WasiConfig.preopen_dir(host_path, guest_mount_path)` grants least-privilege filesystem access
  - Guest sees **only** `/app` (mapped to `workspace/` on host)
  - No ambient filesystem access, no `..` escapes
- **Fuel-Based Deterministic Interruption**: 
  ```python
  cfg.consume_fuel = True
  store.add_fuel(policy.fuel_budget)  # e.g., 2B instructions
  # Exhaustion → wasmtime.Trap (OutOfFuel)
  ```
- **Memory Limiting**: `store.set_limits(memory_size=policy.memory_bytes)`
- **Stdio Capture**: WASI redirects stdout/stderr to temp files with size caps

**Factory Pattern**:
```python
from sandbox import create_sandbox, RuntimeType, ExecutionPolicy

policy = ExecutionPolicy(fuel_budget=1_000_000_000, memory_bytes=64*1024*1024)
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
result = sandbox.execute(code)  # Returns SandboxResult
```

### Testing Strategy

**Comprehensive security boundary testing** - all new features must include attack tests:

- **Test Categories**:
  - `test_*_sandbox.py`: Runtime-specific execution tests
  - `test_*_security.py`: Security boundary tests (fuel exhaustion, filesystem escapes, memory limits)
  - `test_core_models.py`: Pydantic validation tests
  - `test_session_*.py`: Session management tests
  - `test_public_api.py`: API contract tests

- **Security Test Examples**:
  ```python
  # tests/test_python_security.py
  def test_infinite_loop():
      """Should trap with OutOfFuel"""
  
  def test_fs_escape():
      """Should fail to read /etc/passwd"""
  
  def test_memory_blowup():
      """Should hit memory cap"""
  ```

- **Running Tests**:
  ```powershell
  uv run pytest tests/                    # All tests
  uv run pytest tests/test_python_security.py  # Specific suite
  uv run pytest -v --cov=sandbox          # With coverage
  ```

- **Requirements**:
  - All public APIs must have tests
  - Security features must have attack tests
  - Type validation must be tested with invalid inputs
  - Malicious code failures are **expected** - capture in stderr, don't re-raise

### Git Workflow
- **Branching**: Feature branches from `main`
- **Commits**: Descriptive messages, reference issues when applicable
- **Testing**: All tests must pass before merge
- **Changelog**: Update `CHANGELOG.md` for user-facing changes
- **Versioning**: Semantic versioning (MAJOR.MINOR.PATCH)

## Domain Context

**WebAssembly & WASI Security Model**:
- **WASM**: Memory-safe bytecode format with linear memory isolation
- **WASI**: Capability-based system interface (no ambient authority)
- **Wasmtime**: Bytecode Alliance's JIT/AOT WASM runtime
- **Fuel**: Instruction counting mechanism for deterministic execution limits
  - **Limitation**: Cannot preempt blocking WASI host calls (e.g., sleep) - use OS-level timeouts for hard stops
- **Preopens**: WASI's capability grant mechanism for filesystem access

**LLM Integration Context**:
1. LLM generates untrusted code (Python or JavaScript)
2. Create sandbox with runtime and policy
3. Execute code → get typed `SandboxResult`
4. Collect metrics (fuel, duration) + output for LLM feedback loop
5. Use structured logging for observability

**Policy Defaults** (in `ExecutionPolicy` model):
- Fuel: 2B instructions
- Memory: 128 MB
- Stdout cap: 2 MB
- Stderr cap: 1 MB
- Argv: `["python", "/app/user_code.py", "-X", "utf8"]` for Python

## Important Constraints

**Security Constraints** (NEVER violate):
1. **No network access**: WASI baseline doesn't expose sockets unless explicitly added
2. **No capability expansion**: Never add WASI preopens without explicit security review
3. **Validate all policies**: Lowering fuel/memory may break use cases; increasing may enable DoS
4. **Absolute preopen paths**: Relative paths can leak host info via error messages
5. **Env var whitelist**: Only expose explicitly required vars (no `os.environ` passthrough)
6. **Test malicious inputs**: Any new feature must have `tests/test_*_attack.py`

**Technical Constraints**:
- **Single-threaded**: WASM guest is single-threaded (CPython GIL doesn't matter)
- **No async support**: Current `wasmtime-py` lacks async WASI bindings
- **Fuel limitation**: Cannot interrupt blocking host calls (requires OS timeout wrapper)
- **Python 3.11+**: Required for `tomllib` (use `tomli` fallback for older versions)
- **Windows compatibility**: Use PowerShell conventions, `pathlib.Path` for separators

**Defense-in-Depth Layers**:
- **WASM layer** (this project): Memory safety, capability isolation, fuel limits
- **OS layer** (deployment): Run in separate process with OS timeouts, containers/cgroups for multi-tenant
- **Application layer** (integrator): Input validation, output sanitization, rate limiting

## External Dependencies

**Critical Binaries** (not source-controlled, fetched via scripts):
- **CPython WASM**: [WLR AIO releases](https://github.com/webassemblylabs/webassembly-language-runtimes/releases)
  - Fetch: `.\scripts\fetch_wlr_python.ps1`
  - Size: ~50-100 MB
  - Location: `bin/python.wasm`
- **QuickJS WASM**: [QuickJS-NG releases](https://github.com/quickjs-ng/quickjs/releases)
  - Fetch: `.\scripts\fetch_quickjs.ps1`
  - Size: ~1.4 MB
  - Location: `bin/quickjs.wasm`

**Runtime Dependencies**:
- **wasmtime-py**: Pin to `38.*` - API changes frequently, check [changelog](https://github.com/bytecodealliance/wasmtime-py/releases) before upgrading
- **Pydantic**: v2.x for validation (breaking changes from v1)
- **uv**: Package manager - install via `powershell -c "irm https://astral.sh/uv/install.ps1 | iex"`

**Development Dependencies**:
- **pytest**: Testing framework
- **pytest-cov**: Coverage reporting
- **mypy**: Static type checking (future consideration)

**Update Procedures**:
- **WASM binaries**: Update URLs in fetch scripts when new releases available
- **wasmtime**: Test thoroughly before upgrading (breaking API changes common)
- **Dependencies**: Use `uv add <package>` to update `pyproject.toml` and lock file
