# Project Context

## Purpose
Production-grade security sandbox for executing untrusted Python code generated by LLMs using WebAssembly (WASM) and WASI. Provides strong isolation through multi-layered defense combining WASM memory safety, WASI capability-based I/O, deterministic execution limits (fuel), and memory caps. Designed for enterprise scenarios requiring strong isolation and auditability.

## Tech Stack
- **Python 3.11+**: Host runtime (for `tomllib` support)
- **Wasmtime 38.x**: WASM runtime with WASI support (Python bindings)
- **WLR Python (CPython-for-WASI)**: WebAssembly-compiled Python interpreter
- **uv**: Fast Python package manager for dependency management
- **pytest**: Testing framework with coverage reporting
- **TOML**: Configuration format for policies (`tomllib`/`tomli`)
- **PowerShell**: Default shell on Windows development environment

## Project Conventions

### Code Style
- **Type hints required** for all function signatures: `def run_untrusted_python(wasm_path: str = "bin/python.wasm") -> SandboxResult`
- Use `from __future__ import annotations` for forward references
- **Imports**: Conditional TOML parser compatibility (`tomllib` for 3.11+, `tomli` for earlier)
- **Pathlib**: Use `Path` objects for cross-platform path handling
- **Error handling**: Catch specific exceptions (`wasmtime.Trap`), avoid bare `except`
- **No emojis** in code or output unless explicitly requested
- **Docstrings**: Use for public APIs, include security implications
- **Comments**: Explain security boundaries, capability restrictions, and fuel behavior

### Architecture Patterns
**Three-Layer Structure:**
1. **Host Layer** (`sandbox/host.py`): Wasmtime runtime with WASI configuration, fuel budgeting, memory limits
2. **Policy Layer** (`sandbox/policies.py`, `config/policy.toml`): Declarative resource limits and capabilities
3. **Runner Layer** (`sandbox/runner.py`): LLM integration glue - writes untrusted code to `workspace/`, executes, captures results

**WASI Capability-Based Isolation:**
- `WasiConfig.preopen_dir(host_path, guest_mount_path)` for least-privilege filesystem access
- Guest sees only `/app` (mapped to `workspace/` on host)
- No ambient filesystem access, no `..` escapes

**Fuel-Based Deterministic Interruption:**
- `store.add_fuel(policy["fuel_budget"])` for instruction counting
- Exhaustion triggers `wasmtime.Trap` (OutOfFuel)
- Limitation: Cannot preempt blocking WASI host calls

**Stdio Capture Pattern:**
- WASI redirects stdout/stderr to temp files
- Read with size caps to prevent DoS

### Testing Strategy
- **Security-focused testing**: Each test validates a security boundary
- Test files in `tests/` cover malicious inputs:
  - `test_sandbox.py`: Infinite loops (fuel exhaustion), filesystem escapes, memory bombs
- **Expected failures**: Malicious code failures are captured, not raised
- Coverage tracking with pytest-cov (reports in `htmlcov/`)
- Run tests with `uv run pytest`
- All new features require corresponding attack test case

### Git Workflow
- OpenSpec workflow for significant changes (proposals in `openspec/changes/`)
- Commit messages should be descriptive and reference security implications
- Test malicious inputs before committing policy/capability changes

## Domain Context

### WebAssembly Security Model
- **Memory safety**: WASM linear memory cannot escape sandbox
- **Capability-based I/O**: WASI requires explicit grants for filesystem/network
- **No ambient authority**: Guest cannot access host resources without explicit preopen
- **Deterministic execution**: Fuel mechanism enables instruction-level accounting

### LLM Integration Patterns
1. LLM generates Python code (untrusted)
2. `runner.write_untrusted_code(code)` writes to `workspace/user_code.py`
3. `host.run_untrusted_python()` executes in WASM sandbox
4. Collect metrics (`fuel_consumed`, memory usage) + output for LLM feedback loop

### Policy Defaults (Centralized in `sandbox/policies.py`)
- **Fuel**: 400M instructions (~multi-second execution on modern CPU)
- **Memory**: 64 MB linear memory limit
- **Stdout**: 1 MB capture cap
- **Stderr**: 500 KB capture cap
- **Argv**: `["python", "/app/user_code.py", "-X", "utf8"]`
- Merge user `policy.toml` with defaults using dict union (`|` operator)

## Important Constraints

### Security Constraints (Defense-in-Depth)
- **Never expand WASI capabilities** without explicit security review
- **No networking**: WASI baseline doesn't expose sockets unless explicitly added
- **Preopen paths must be absolute**: Relative paths can leak host info via error messages
- **Env var whitelist**: Only expose explicitly required vars (no `os.environ` passthrough)
- **Validate policy changes**: Increasing limits may enable DoS attacks

### Technical Limitations
- **Blocking host calls**: Fuel cannot interrupt sleep/blocking I/O - requires OS-level timeout wrapper
- **No async support**: Current `wasmtime-py` lacks async WASI bindings (epochs feature not exposed)
- **Single-threaded**: WASM guest is single-threaded
- **Wasmtime API stability**: API changes frequently - pin major/minor version (`wasmtime==38.*`)

### Platform Constraints
- **Windows development**: PowerShell default, bash scripts require Git Bash/WSL or adaptation
- **uv requirement**: All Python commands use `uv run` prefix for environment management
- **Binary artifact**: `python.wasm` is downloaded (~50-100 MB), not source-controlled

## External Dependencies

### Critical External Artifacts
- **WLR Python Binary**: WebAssembly Language Runtimes CPython-for-WASI
  - Source: https://github.com/webassemblylabs/webassembly-language-runtimes/releases
  - Download script: `scripts/fetch_wlr_python.ps1`
  - Location: `bin/python.wasm`
  - Update frequency: Quarterly (monitor releases)

### Python Package Dependencies
- **wasmtime==38.x**: Core WASM runtime (PINNED - breaking changes in new versions)
- **tomli**: TOML parser for Python <3.11 compatibility
- **pytest**: Testing framework
- **pytest-cov**: Coverage reporting

### Vendored Dependencies
- **certifi, charset-normalizer, idna, urllib3**: HTTP client stack
- Located in `vendor/site-packages/` and `workspace/site-packages/`
- Managed by `scripts/manage_vendor.py`
- Reason: Guest code may need HTTP requests without network capability (pre-bundled)
