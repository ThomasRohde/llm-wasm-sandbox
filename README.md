<div align="center">

# ğŸ”’ LLM WASM Sandbox

**Production-grade security sandbox for executing untrusted Python & JavaScript code generated by LLMs**

[![Python 3.11+](https://img.shields.io/badge/python-3.11+-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Wasmtime](https://img.shields.io/badge/wasmtime-38.x-green.svg)](https://github.com/bytecodealliance/wasmtime-py)

Execute untrusted code safely using WebAssembly sandboxing with multi-layered security:

ğŸ” **WASM Memory Safety** - Bounds-checked execution  
ğŸ›¡ï¸ **WASI Capability-Based I/O** - Filesystem isolation  
â±ï¸ **Deterministic Limits** - Fuel metering & resource caps  
ğŸ **Python & JavaScript** - CPython WASM + QuickJS runtimes

![LLM WASM Sandbox Architecture](llm-wasm-sandbox.jpeg)

</div>

---

## ğŸ“‹ Table of Contents

- [Features](#-features)
- [Quick Start](#-quick-start)
- [Architecture](#-architecture)
- [LLM Integration](#-llm-integration)
- [Security Model](#-security-model)
- [Troubleshooting](#-troubleshooting)
- [Development](#ï¸-development)
- [Contributing](#-contributing)
- [License](#-license)

---

## âœ¨ Features

- **ğŸ”’ Production-Grade Security**: Multi-layered defense with WASM memory safety, WASI capabilities, and resource limits
- **ğŸ Python Runtime**: CPython 3.11 compiled to WASM via WebAssembly Language Runtimes
- **ğŸ“œ JavaScript Runtime**: QuickJS-NG WASM for secure JavaScript execution
- **âš¡ Deterministic Execution**: Fuel-based instruction counting prevents runaway code
- **ğŸ“¦ Package Vendoring**: Pure-Python packages available in sandbox via `vendor/` directory
- **ğŸ’¾ Persistent Sessions**: UUID-based session IDs with automatic workspace isolation
- **ğŸ—‚ï¸ Pluggable Storage**: Storage adapter interface with disk and custom backend support
- **ğŸ“Š Rich Metrics**: Fuel consumption, memory usage, execution time tracking
- **ğŸ¯ Type-Safe API**: Pydantic models for policies and results
- **ğŸ” Structured Logging**: Observable execution events for monitoring
- **ğŸ§¹ Session Pruning**: Automatic cleanup of old sessions with configurable retention policies

---

## ğŸš€ Quick Start

### Prerequisites

- Python 3.11+ (Python 3.13+ recommended)
- [uv](https://docs.astral.sh/uv/) package manager (recommended) or pip
- Windows, macOS, or Linux

### Installation

#### From PyPI (Recommended)

```bash
# Install the package
pip install llm-wasm-sandbox

# Download WASM runtimes (required for execution)
# On Windows (PowerShell)
Invoke-WebRequest -Uri "https://github.com/ThomasRohde/llm-wasm-sandbox/raw/main/scripts/fetch_wlr_python.ps1" -OutFile "fetch_wlr_python.ps1"
.\fetch_wlr_python.ps1

Invoke-WebRequest -Uri "https://github.com/ThomasRohde/llm-wasm-sandbox/raw/main/scripts/fetch_quickjs.ps1" -OutFile "fetch_quickjs.ps1"
.\fetch_quickjs.ps1

# On Linux/macOS
curl -O https://github.com/ThomasRohde/llm-wasm-sandbox/raw/main/scripts/fetch_wlr_python.sh
chmod +x fetch_wlr_python.sh
./fetch_wlr_python.sh
```

#### From Source

```powershell
# Clone the repository
git clone https://github.com/ThomasRohde/llm-wasm-sandbox.git
cd llm-wasm-sandbox

# Install dependencies (uv recommended)
uv sync
# OR with pip
pip install -r requirements.txt

# Download WASM runtimes
.\scripts\fetch_wlr_python.ps1   # CPython WASM binary
.\scripts\fetch_quickjs.ps1       # QuickJS WASM binary
```

### Hello World

**Python Runtime:**
```python
from sandbox import create_sandbox, RuntimeType

sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
result = sandbox.execute("print('Hello from WASM!')")
print(result.stdout)  # "Hello from WASM!"
```

**JavaScript Runtime:**
```python
from sandbox import create_sandbox, RuntimeType

sandbox = create_sandbox(runtime=RuntimeType.JAVASCRIPT)
result = sandbox.execute("console.log('Hello from QuickJS!')")
print(result.stdout)  # "Hello from QuickJS!"
```

### Run Demo

```powershell
# Python demo with comprehensive examples
uv run python demo.py

# JavaScript demo (single execution)
uv run python demo_javascript.py

# JavaScript session demo (stateful execution)
uv run python demo_javascript_session.py

# Session workflow demo (file operations)
uv run python demo_session_workflow.py
```

---

## ğŸ—ï¸ Architecture

### Project Structure

```
llm-wasm-sandbox/
â”œâ”€â”€ bin/
â”‚   â”œâ”€â”€ python.wasm               # CPython WASM binary (downloaded)
â”‚   â””â”€â”€ quickjs.wasm              # QuickJS WASM binary (downloaded)
â”œâ”€â”€ config/
â”‚   â””â”€â”€ policy.toml               # Execution policy configuration
â”œâ”€â”€ sandbox/
â”‚   â”œâ”€â”€ core/                     # Type-safe foundation
â”‚   â”‚   â”œâ”€â”€ models.py             # ExecutionPolicy, SandboxResult, RuntimeType
â”‚   â”‚   â”œâ”€â”€ base.py               # BaseSandbox ABC
â”‚   â”‚   â”œâ”€â”€ errors.py             # Custom exceptions
â”‚   â”‚   â”œâ”€â”€ logging.py            # Structured logging
â”‚   â”‚   â”œâ”€â”€ factory.py            # create_sandbox() factory
â”‚   â”‚   â””â”€â”€ storage.py            # Storage adapter interface
â”‚   â”œâ”€â”€ runtimes/                 # Runtime implementations
â”‚   â”‚   â”œâ”€â”€ python/
â”‚   â”‚   â”‚   â””â”€â”€ sandbox.py        # PythonSandbox
â”‚   â”‚   â””â”€â”€ javascript/
â”‚   â”‚       â””â”€â”€ sandbox.py        # JavaScriptSandbox
â”‚   â”œâ”€â”€ host.py                   # Wasmtime/WASI wrapper
â”‚   â”œâ”€â”€ policies.py               # Policy loading
â”‚   â”œâ”€â”€ sessions.py               # Session file operations & pruning
â”‚   â”œâ”€â”€ utils.py                  # Utilities
â”‚   â””â”€â”€ vendor.py                 # Package vendoring
â”œâ”€â”€ workspace/                   # Isolated filesystem (mounted as /app)
â”‚   â””â”€â”€ <session-id>/            # Per-session workspaces
â”œâ”€â”€ vendor/                      # Vendored pure-Python packages
â”‚   â””â”€â”€ site-packages/
â”œâ”€â”€ demo.py                      # Comprehensive feature demo
â”œâ”€â”€ pyproject.toml               # Project metadata & dependencies
â””â”€â”€ README.md                    # This file
```

---

## ğŸ¤– LLM Integration

### Integration Flow

Typical usage in an LLM code generation pipeline:

```mermaid
graph LR
    A[LLM generates code] --> B[Create sandbox]
    B --> C[Execute in WASM]
    C --> D[Collect metrics]
    D --> E{Success?}
    E -->|Yes| F[Return results]
    E -->|No| G[Send feedback to LLM]
    G --> A
```

### Example Integration

```python
from sandbox import create_sandbox, ExecutionPolicy, RuntimeType

def execute_llm_code(llm_generated_code: str) -> dict:
    """Execute LLM-generated code with safety boundaries."""
    
    # Configure conservative limits for LLM code
    policy = ExecutionPolicy(
        fuel_budget=500_000_000,      # Fail fast on complex code
        memory_bytes=32 * 1024 * 1024,  # 32 MB limit
        stdout_max_bytes=100_000        # 100 KB output
    )
    
    sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
    result = sandbox.execute(llm_generated_code)
    
    # Provide structured feedback for LLM
    if not result.success:
        return {
            "status": "error",
            "feedback": f"Execution failed: {result.stderr}",
            "suggestion": "Simplify the code and avoid complex operations"
        }
    
    if result.fuel_consumed > 400_000_000:
        return {
            "status": "warning",
            "feedback": "Code complexity too high",
            "fuel_used": result.fuel_consumed,
            "suggestion": "Optimize algorithm for better efficiency"
        }
    
    return {
        "status": "success",
        "output": result.stdout,
        "metrics": {
            "fuel": result.fuel_consumed,
            "duration": result.duration_seconds,
            "memory_pages": result.mem_pages
        }
    }

# Use in LLM loop
code = generate_code_from_llm("Calculate fibonacci(10)")
feedback = execute_llm_code(code)
print(feedback)
```

### Multi-Turn Sessions

For stateful LLM interactions with file persistence:

```python
from sandbox import create_sandbox, RuntimeType

# Turn 1: LLM creates data file
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
session_id = sandbox.session_id

result1 = sandbox.execute("""
import json
data = {"users": ["Alice", "Bob"], "count": 2}
with open('/app/data.json', 'w') as f:
    json.dump(data, f)
print("Data saved")
""")

# Turn 2: LLM reads and processes data (same session)
sandbox = create_sandbox(session_id=session_id, runtime=RuntimeType.PYTHON)

result2 = sandbox.execute("""
import json
with open('/app/data.json', 'r') as f:
    data = json.load(f)
data['users'].append('Charlie')
data['count'] = len(data['users'])
print(f"Updated: {data}")
""")

print(result2.stdout)  # "Updated: {'users': ['Alice', 'Bob', 'Charlie'], 'count': 3}"
```

Session workspaces are canonicalized before creation (no `/`, `\\`, or `..` in
IDs) and you can enforce UUID-only IDs via `allow_non_uuid=False`. Vendored
packages are copied per-session so one guest cannot poison another, optional
`mount_data_dir` mounts are read-only, and host-side logs are cleaned up unless
you opt in with `ExecutionPolicy(preserve_logs=True)`.

### Session Management API

Direct session file operations and pruning:

```python
from sandbox import (
    create_sandbox, RuntimeType,
    write_session_file, read_session_file, list_session_files,
    prune_sessions, delete_session_workspace
)

# Create sandbox and write files
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
write_session_file(sandbox.session_id, "data.json", '{"key": "value"}')

# List all files in session
files = list_session_files(sandbox.session_id)
print(files)  # ['data.json', 'user_code.py']

# Read file content
content = read_session_file(sandbox.session_id, "data.json")

# Prune old sessions (e.g., older than 7 days)
result = prune_sessions(max_age_days=7)
print(f"Deleted {result.deleted_count} sessions, freed {result.bytes_freed} bytes")

# Delete specific session
delete_session_workspace(sandbox.session_id)
```

### Pluggable Storage Adapters

Customize storage backend for sessions:

```python
from sandbox import create_sandbox, RuntimeType, StorageAdapter
from pathlib import Path

class CustomStorage(StorageAdapter):
    """Custom storage backend (e.g., S3, Azure Blob)."""
    
    def read(self, path: Path) -> bytes:
        # Implement custom read logic
        pass
    
    def write(self, path: Path, content: bytes) -> None:
        # Implement custom write logic
        pass
    
    def delete(self, path: Path) -> None:
        # Implement custom delete logic
        pass
    
    def exists(self, path: Path) -> bool:
        # Implement custom exists check
        pass

# Use custom storage
storage = CustomStorage()
sandbox = create_sandbox(
    runtime=RuntimeType.PYTHON,
    storage_adapter=storage
)
```

### Agent Integration Examples

For production LLM agent integrations, see the [OpenAI Agents SDK integration examples](examples/openai_agents/):

**Basic Agent** ([`examples/openai_agents/basic_agent.py`](examples/openai_agents/basic_agent.py)):
- Function calling tools for Python/JavaScript execution
- Structured result handling with security metrics
- Conservative execution policies for untrusted code

**Stateful Agent** ([`examples/openai_agents/stateful_agent.py`](examples/openai_agents/stateful_agent.py)):
- Session-based multi-turn conversations
- File persistence across agent interactions
- Automatic error recovery and debugging

See the [OpenAI Agents integration README](examples/openai_agents/README.md) for setup instructions and detailed usage patterns.

---

## ï¿½ Available Python Capabilities

### Python Standard Library

The WASM sandbox includes CPython 3.11+ with extensive standard library support:

**File & I/O Operations**
- `pathlib`, `os.path` - Path manipulation (within `/app` only)
- `shutil` - File copying and directory operations
- `glob` - Pattern matching for file search
- `tempfile` - Temporary file creation (within `/app`)

**Text & Data Processing**
- `re` - Regular expressions
- `json` - JSON encoding/decoding
- `csv` - CSV file reading/writing
- `xml.etree.ElementTree` - XML parsing
- `tomllib` (3.11+) or `tomli` - TOML parsing
- `base64`, `binascii` - Binary encoding
- `hashlib` - Cryptographic hashing (SHA, MD5, etc.)

**Data Structures & Utilities**
- `collections` - deque, Counter, defaultdict, etc.
- `itertools` - Iterator utilities
- `functools` - Functional programming tools
- `typing` - Type hints and annotations

**Date & Time**
- `datetime` - Date/time manipulation
- `time` - Time operations
- `calendar` - Calendar utilities

**Math & Statistics**
- `math` - Mathematical functions
- `statistics` - Statistical functions
- `random` - Random number generation
- `decimal`, `fractions` - Precise numeric types

**Text & Strings**
- `string` - String constants and utilities
- `textwrap` - Text wrapping and formatting
- `difflib` - Text comparison

**Data Compression**
- `zipfile` - ZIP archive handling
- `gzip`, `bz2`, `lzma` - Compression formats

### Vendored Pure-Python Packages

Pre-installed packages available via `sys.path.insert(0, '/app/site-packages')`:

**Document Processing**
- `openpyxl` - Read/write Excel (.xlsx) files
- `XlsxWriter` - Write Excel files (lighter alternative)
- `PyPDF2` - Read/write/merge PDF files
- `odfpy` - OpenDocument Format (.odf, .ods, .odp)
- `mammoth` - Convert Word (.docx) to HTML/Markdown

**HTTP & Encoding** (Note: networking disabled in baseline WASI)
- `certifi`, `charset-normalizer`, `idna`, `urllib3`
- Useful for data encoding/decoding even without network access

**Date/Time Extensions**
- `python-dateutil` - Advanced date parsing and arithmetic

**Text Processing**
- `tabulate` - Pretty-print tables (ASCII, Markdown, HTML)
- `jinja2` + `MarkupSafe` - Template rendering (âš ï¸ requires 5B fuel budget)
- `markdown` - Markdown to HTML conversion

**Data Modeling**
- `attrs` - Classes without boilerplate

**Compatibility**
- `six` - Python 2/3 compatibility utilities
- `tomli` - TOML parser (Python <3.11)

### `sandbox_utils` Library

Shell-like utilities purpose-built for LLM code generation:

**File Operations**
```python
from sandbox_utils import find, tree, walk, copy_tree, remove_tree

# Find files matching pattern
files = find("*.py", "/app", recursive=True)

# Display directory tree
print(tree("/app", max_depth=3))

# Filtered directory traversal
for path in walk("/app", filter_func=lambda p: p.suffix == ".json"):
    print(path)
```

**Text Processing**
```python
from sandbox_utils import grep, sed, head, tail, wc, diff

# Search for pattern in files
matches = grep(r"ERROR", files, regex=True)

# Regex replacement
text = sed(r"foo(\d+)", r"bar\1", "foo123 foo456")

# Read first/last lines
content = head("/app/log.txt", lines=10)
```

**Data Manipulation**
```python
from sandbox_utils import group_by, filter_by, sort_by, unique, chunk

# Group items by key
groups = group_by(users, lambda u: u["country"])

# Filter and sort
active = filter_by(users, lambda u: u["active"])
sorted_users = sort_by(active, lambda u: u["created_at"], reverse=True)
```

**Format Conversions**
```python
from sandbox_utils import csv_to_json, json_to_csv, xml_to_dict

# Convert CSV to JSON
json_str = csv_to_json("/app/data.csv", output="/app/data.json")

# Parse XML to dict
data = xml_to_dict('<root><item id="1">value</item></root>')
```

**Shell Emulation**
```python
from sandbox_utils import ls, cat, touch, mkdir, rm, cp, mv, echo

# List directory
items = ls("/app", long=True)  # Returns list of dicts with metadata

# Concatenate files
content = cat("/app/file1.txt", "/app/file2.txt")

# Create/copy/move files
touch("/app/newfile.txt")
cp("/app/source.txt", "/app/dest.txt")
mv("/app/old.txt", "/app/new.txt")
```

**Security Note**: All `sandbox_utils` functions enforce `/app` path validation and reject `..` traversal attempts.

### Usage Examples

**Basic Import Pattern**
```python
# Make vendored packages available
import sys
sys.path.insert(0, '/app/site-packages')

# Now import vendored packages
import openpyxl
from tabulate import tabulate
from sandbox_utils import find, grep
```

**Complete Workflow Example**
```python
import sys
sys.path.insert(0, '/app/site-packages')

from sandbox_utils import find, grep, csv_to_json
from tabulate import tabulate
import json

# Find all CSV files
csv_files = find("*.csv", "/app")

# Search for errors in log files
log_files = find("*.log", "/app")
errors = grep(r"ERROR.*timeout", log_files)

# Convert CSV to JSON and process
for csv_file in csv_files:
    json_file = str(csv_file).replace('.csv', '.json')
    csv_to_json(str(csv_file), output=json_file)
    
# Load and display data
with open('/app/data.json') as f:
    data = json.load(f)
    
table = tabulate(data, headers="keys", tablefmt="markdown")
print(table)
```

### Performance Considerations

**Fuel Budget Guidelines** (default: 2B instructions)

| Operation | Typical Fuel | Notes |
|-----------|--------------|-------|
| `find()` 100 files | ~5M | Linear in file count |
| `grep()` 1MB text | ~20M | Depends on regex complexity |
| `csv_to_json()` 10K rows | ~50M | Depends on row size |
| `tree()` 500 dirs | ~10M | Linear in directory count |
| First `import jinja2` | ~4B | âš ï¸ Requires 5B fuel budget |
| Import openpyxl | ~3-5B | First import only |
| Import PyPDF2 | ~3B | First import only |

**Tips for Efficient Code**:
- Cached imports: After first execution, imports in same session use cached modules
- Use `chunk()` for large datasets to process in batches
- Prefer `walk()` iterator over `find()` for very large directories
- Set higher fuel budgets for document processing: `ExecutionPolicy(fuel_budget=5_000_000_000)`

---

## ï¿½ğŸ”’ Security Model

### Multi-Layered Defense

This sandbox implements defense-in-depth with multiple security boundaries:

#### 1. **WASM Memory Safety**
- Bounds-checked linear memory (no buffer overflows)
- Validated control flow (no arbitrary jumps)
- Type-safe execution (strong typing enforced)

#### 2. **WASI Capability-Based I/O**
- **Preopens only**: File access limited to explicitly granted directories
- **No path traversal**: `..` and absolute paths outside capabilities are denied
- **Descriptor-based**: All I/O goes through validated capability descriptors

#### 3. **Deterministic Execution Limits**
- **Fuel metering**: Instruction-count budgets enforce hard time limits
- **OutOfFuel trap**: Exhausted budget triggers immediate termination
- **No runaway loops**: Infinite loops hit fuel limit automatically

#### 4. **Resource Caps**
- **Memory limit**: WASM linear memory capped at configured size
- **Output limits**: Stdout/stderr truncated to prevent DoS
- **No networking**: Zero network capabilities (no sockets)
- **No subprocesses**: Cannot spawn child processes

### Security Boundaries

| Boundary | Mechanism | Protection |
|----------|-----------|------------|
| **Memory** | WASM bounds checking | Prevents buffer overflows, use-after-free |
| **Filesystem** | WASI preopens | Restricts access to mounted directories only |
| **CPU** | Fuel metering | Prevents infinite loops, excessive computation |
| **I/O** | Capability descriptors | No ambient authority, explicit grants |
| **Environment** | Variable whitelist | Prevents info leaks, credentials exposure |

### Production Hardening

For production deployments, combine with OS-level security:

```python
import subprocess
import signal
from pathlib import Path

def execute_with_timeout(code: str, timeout_seconds: int = 30):
    """Execute sandbox in separate process with OS timeout."""
    
    script = f"""
from sandbox import create_sandbox, RuntimeType
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
result = sandbox.execute({code!r})
print(result.stdout)
"""
    
    try:
        result = subprocess.run(
            ["python", "-c", script],
            timeout=timeout_seconds,
            capture_output=True,
            text=True
        )
        return result.stdout
    except subprocess.TimeoutExpired:
        return "Execution timeout (OS limit)"
```

### Additional Recommendations

- ğŸ³ **Containers**: Run sandbox in Docker/Podman for additional isolation
- ğŸ“¦ **cgroups**: Use Linux cgroups for CPU/memory limits
- ğŸ“Š **Monitoring**: Log all executions with code hashes for audit trails
- â±ï¸ **OS Timeouts**: Combine fuel limits with OS-level process timeouts
- ğŸ” **Network Isolation**: Deploy in network-restricted environments

---

## ğŸ”§ Troubleshooting

### Common Issues

<details>
<summary><b>ğŸš¨ <code>python.wasm not found</code></b></summary>

**Solution:** Download the WASM binary
```powershell
.\scripts\fetch_wlr_python.ps1
```

**Verify:** Check that `bin/python.wasm` exists and is ~50-100 MB

</details>

<details>
<summary><b>ğŸš¨ <code>ImportError: wasmtime could not be imported</code></b></summary>

**Solution:** Install dependencies
```powershell
uv sync
# OR
pip install -r requirements.txt
```

**Verify:** `python -c "import wasmtime; print(wasmtime.__version__)"`

</details>

<details>
<summary><b>ğŸš¨ <code>OutOfFuel</code> trap during execution</b></summary>

**Cause:** Code exceeded instruction budget

**Solution:** Increase fuel budget or simplify code
```python
policy = ExecutionPolicy(fuel_budget=5_000_000_000)  # Increase limit
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
```

</details>

<details>
<summary><b>ğŸš¨ Memory limit errors</b></summary>

**Cause:** WASM memory cap exceeded

**Solution:** Increase memory limit
```python
policy = ExecutionPolicy(memory_bytes=256 * 1024 * 1024)  # 256 MB
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
```

</details>

<details>
<summary><b>ğŸš¨ <code>FileNotFoundError</code> in guest code</b></summary>

**Cause:** Path outside preopened directories

**Solution:** Use `/app` prefix for all file operations
```python
# âŒ Wrong
open('data.txt', 'r')

# âœ… Correct
open('/app/data.txt', 'r')
```

</details>

<details>
<summary><b>ğŸš¨ <code>ModuleNotFoundError</code> for package</b></summary>

**Cause:** Package not vendored or not in sys.path

**Solution 1: Use pre-vendored packages**

Check if the package is already vendored (see [Available Python Capabilities](#-available-python-capabilities)):
```python
import sys
sys.path.insert(0, '/app/site-packages')
import openpyxl  # or any other vendored package
```

**Solution 2: Vendor a new pure-Python package**
```powershell
# Install to vendor directory
uv run python scripts/manage_vendor.py install <package-name>

# Copy to workspace
uv run python scripts/manage_vendor.py copy
```

Then use in sandboxed code:
```python
import sys
sys.path.insert(0, '/app/site-packages')
import <package-name>
```

**Note:** Only pure-Python packages work in WASM. Packages with C/Rust extensions will fail.

</details>

<details>
<summary><b>ğŸš¨ <code>ImportError</code> from vendored package</b></summary>

**Cause:** Package has native dependencies or missing dependencies

**Solution:** Check if package is pure-Python
```powershell
# Test package compatibility
uv run python -c "
from sandbox import create_sandbox, RuntimeType
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
result = sandbox.execute('''
import sys
sys.path.insert(0, \"/app/site-packages\")
import <package-name>
print(\"Package loaded successfully\")
''')
print(result.stdout if result.success else result.stderr)
"
```

**Known incompatible packages:**
- `jsonschema` (requires `rpds-py` Rust extension)
- `python-docx` (requires `lxml` C extension)
- `pdfminer.six` (requires `cryptography` C extension)

**Alternatives:**
- For JSON validation: Use manual validation or simpler libraries
- For .docx: Use `mammoth` (vendored, pure-Python)
- For PDF: Use `PyPDF2` (vendored, pure-Python)

</details>

<details>
<summary><b>ğŸš¨ High fuel consumption with `jinja2` or document packages</b></summary>

**Cause:** Large packages consume significant fuel on first import

**Solution:** Increase fuel budget for document processing
```python
from sandbox import create_sandbox, ExecutionPolicy, RuntimeType

policy = ExecutionPolicy(
    fuel_budget=5_000_000_000  # 5B for jinja2, openpyxl, PyPDF2
)
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
```

**Fuel requirements:**
- `jinja2`: ~4B instructions (first import)
- `openpyxl`: ~3-5B instructions (first import)
- `PyPDF2`: ~3B instructions (first import)
- `tabulate`, `markdown`: <2B (works with default)

**Note:** Subsequent executions in the same session use cached imports (lower fuel).

</details>

<details>
<summary><b>ğŸš¨ <code>sandbox_utils</code> path validation errors</b></summary>

**Cause:** Attempting to access files outside `/app` or using `..` traversal

**Examples of errors:**
```
ValueError: Path must be within /app: /etc/passwd
ValueError: Path must be within /app: /app/../etc
```

**Solution:** Always use absolute paths within `/app` or relative paths
```python
from sandbox_utils import find, ls

# âœ… Correct - absolute path in /app
files = find("*.txt", "/app/data")

# âœ… Correct - relative path (becomes /app/data)
files = find("*.txt", "data")

# âŒ Wrong - outside /app
files = find("*.txt", "/etc")  # Raises ValueError

# âŒ Wrong - traversal attempt
files = find("*.txt", "/app/../etc")  # Raises ValueError
```

</details>

### Getting Help

- ğŸ **Report bugs**: [GitHub Issues](https://github.com/ThomasRohde/llm-wasm-sandbox/issues)
- ğŸ“– **Documentation**: See inline code comments and docstrings
- ğŸ’¡ **Examples**: Check `demo*.py` files and `tests/` directory

---

## ğŸ› ï¸ Development

### Running Tests

```powershell
# Run all tests with coverage
uv run pytest tests/ -v --cov=sandbox --cov-report=html

# Run specific test file
uv run pytest tests/test_python_sandbox.py -v

# Run tests matching pattern
uv run pytest tests/ -k "session" -v
```

### Code Quality

```powershell
# Type checking
uv run mypy sandbox/

# Linting and formatting
uv run ruff check sandbox/
uv run ruff format sandbox/
```

### Benchmarking

```powershell
# Performance benchmarks
uv run python benchmark_performance.py

# Session performance
uv run python benchmark_session_performance.py
```

---

## ğŸ¤ Contributing

Contributions are welcome! Please follow these guidelines:

1. **Fork** the repository
2. **Create** a feature branch (`git checkout -b feature/amazing-feature`)
3. **Commit** your changes (`git commit -m 'Add amazing feature'`)
4. **Push** to the branch (`git push origin feature/amazing-feature`)
5. **Open** a Pull Request

### Development Setup

```powershell
# Clone your fork
git clone https://github.com/YOUR-USERNAME/llm-wasm-sandbox.git
cd llm-wasm-sandbox

# Install dev dependencies
uv sync

# Fetch WASM binaries
.\scripts\fetch_wlr_python.ps1
.\scripts\fetch_quickjs.ps1

# Run tests to verify setup
uv run pytest tests/ -v
```

---

## ğŸ“ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## ğŸ”— References & Resources

- **Wasmtime Security**: https://docs.wasmtime.dev/security.html
- **WASI Capabilities**: https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-capabilities.md
- **WebAssembly Language Runtimes**: https://github.com/webassemblylabs/webassembly-language-runtimes
- **Wasmtime Python Bindings**: https://github.com/bytecodealliance/wasmtime-py
- **WASI Specification**: https://github.com/WebAssembly/WASI

---

## ğŸš€ Roadmap

- [x] JavaScript runtime support (QuickJS WASM)
- [x] Pluggable storage adapter interface
- [x] Session pruning and lifecycle management
- [ ] Improved async execution support
- [ ] Network sandboxing with explicit socket grants
- [ ] Enhanced metrics and profiling
- [ ] Web-based demo interface
- [ ] Additional runtime support (Ruby, Lua)

---

<div align="center">

**Built with â¤ï¸ for secure LLM code execution**

[Report Bug](https://github.com/ThomasRohde/llm-wasm-sandbox/issues) â€¢
[Request Feature](https://github.com/ThomasRohde/llm-wasm-sandbox/issues) â€¢
[Documentation](https://github.com/ThomasRohde/llm-wasm-sandbox)

</div>
