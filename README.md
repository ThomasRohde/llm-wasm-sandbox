<div align="center">

# ğŸ”’ LLM WASM Sandbox

**Production-grade security sandbox for executing untrusted Python & JavaScript code generated by LLMs**

[![Python 3.11+](https://img.shields.io/badge/python-3.11+-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Wasmtime](https://img.shields.io/badge/wasmtime-38.x-green.svg)](https://github.com/bytecodealliance/wasmtime-py)

Execute untrusted code safely using WebAssembly sandboxing with multi-layered security:

ğŸ” **WASM Memory Safety** - Bounds-checked execution  
ğŸ›¡ï¸ **WASI Capability-Based I/O** - Filesystem isolation  
â±ï¸ **Deterministic Limits** - Fuel metering & resource caps  
ğŸ **Python & JavaScript** - CPython WASM + QuickJS runtimes

![LLM WASM Sandbox Architecture](llm-wasm-sandbox.jpeg)

</div>

---

## ğŸ“‹ Table of Contents

- [Features](#-features)
- [Quick Start](#-quick-start)
- [Architecture](#-architecture)
- [LLM Integration](#-llm-integration)
- [Security Model](#-security-model)
- [Troubleshooting](#-troubleshooting)
- [Development](#ï¸-development)
- [Contributing](#-contributing)
- [License](#-license)

---

## âœ¨ Features

- **ğŸ”’ Production-Grade Security**: Multi-layered defense with WASM memory safety, WASI capabilities, and resource limits
- **ğŸ Python Runtime**: CPython 3.11 compiled to WASM via WebAssembly Language Runtimes
- **ğŸ“œ JavaScript Runtime**: QuickJS-NG WASM for secure JavaScript execution
- **âš¡ Deterministic Execution**: Fuel-based instruction counting prevents runaway code
- **ğŸ“¦ Package Vendoring**: Pure-Python packages available in sandbox via `vendor/` directory
- **ğŸ’¾ Persistent Sessions**: UUID-based session IDs with automatic workspace isolation
- **ğŸ—‚ï¸ Pluggable Storage**: Storage adapter interface with disk and custom backend support
- **ğŸ“Š Rich Metrics**: Fuel consumption, memory usage, execution time tracking
- **ğŸ¯ Type-Safe API**: Pydantic models for policies and results
- **ğŸ” Structured Logging**: Observable execution events for monitoring
- **ğŸ§¹ Session Pruning**: Automatic cleanup of old sessions with configurable retention policies

---

## ğŸš€ Quick Start

### Prerequisites

- Python 3.11+ (Python 3.13+ recommended)
- [uv](https://docs.astral.sh/uv/) package manager (recommended) or pip
- Windows, macOS, or Linux

### Installation

```powershell
# Clone the repository
git clone https://github.com/yourusername/llm-wasm-sandbox.git
cd llm-wasm-sandbox

# Install dependencies (uv recommended)
uv sync
# OR with pip
pip install -r requirements.txt

# Download WASM runtimes
.\scripts\fetch_wlr_python.ps1   # CPython WASM binary
.\scripts\fetch_quickjs.ps1       # QuickJS WASM binary
```

### Hello World

**Python Runtime:**
```python
from sandbox import create_sandbox, RuntimeType

sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
result = sandbox.execute("print('Hello from WASM!')")
print(result.stdout)  # "Hello from WASM!"
```

**JavaScript Runtime:**
```python
from sandbox import create_sandbox, RuntimeType

sandbox = create_sandbox(runtime=RuntimeType.JAVASCRIPT)
result = sandbox.execute("console.log('Hello from QuickJS!')")
print(result.stdout)  # "Hello from QuickJS!"
```

### Run Demo

```powershell
# Python demo with comprehensive examples
uv run python demo.py

# JavaScript demo (single execution)
uv run python demo_javascript.py

# JavaScript session demo (stateful execution)
uv run python demo_javascript_session.py

# Session workflow demo (file operations)
uv run python demo_session_workflow.py
```

---

## ğŸ—ï¸ Architecture

### Project Structure

```
llm-wasm-sandbox/
â”œâ”€â”€ bin/
â”‚   â”œâ”€â”€ python.wasm               # CPython WASM binary (downloaded)
â”‚   â””â”€â”€ quickjs.wasm              # QuickJS WASM binary (downloaded)
â”œâ”€â”€ config/
â”‚   â””â”€â”€ policy.toml               # Execution policy configuration
â”œâ”€â”€ sandbox/
â”‚   â”œâ”€â”€ core/                     # Type-safe foundation
â”‚   â”‚   â”œâ”€â”€ models.py             # ExecutionPolicy, SandboxResult, RuntimeType
â”‚   â”‚   â”œâ”€â”€ base.py               # BaseSandbox ABC
â”‚   â”‚   â”œâ”€â”€ errors.py             # Custom exceptions
â”‚   â”‚   â”œâ”€â”€ logging.py            # Structured logging
â”‚   â”‚   â”œâ”€â”€ factory.py            # create_sandbox() factory
â”‚   â”‚   â””â”€â”€ storage.py            # Storage adapter interface
â”‚   â”œâ”€â”€ runtimes/                 # Runtime implementations
â”‚   â”‚   â”œâ”€â”€ python/
â”‚   â”‚   â”‚   â””â”€â”€ sandbox.py        # PythonSandbox
â”‚   â”‚   â””â”€â”€ javascript/
â”‚   â”‚       â””â”€â”€ sandbox.py        # JavaScriptSandbox
â”‚   â”œâ”€â”€ host.py                   # Wasmtime/WASI wrapper
â”‚   â”œâ”€â”€ policies.py               # Policy loading
â”‚   â”œâ”€â”€ sessions.py               # Session file operations & pruning
â”‚   â”œâ”€â”€ utils.py                  # Utilities
â”‚   â””â”€â”€ vendor.py                 # Package vendoring
â”œâ”€â”€ workspace/                   # Isolated filesystem (mounted as /app)
â”‚   â””â”€â”€ <session-id>/            # Per-session workspaces
â”œâ”€â”€ vendor/                      # Vendored pure-Python packages
â”‚   â””â”€â”€ site-packages/
â”œâ”€â”€ demo.py                      # Comprehensive feature demo
â”œâ”€â”€ pyproject.toml               # Project metadata & dependencies
â””â”€â”€ README.md                    # This file
```

---

## ğŸ¤– LLM Integration

### Integration Flow

Typical usage in an LLM code generation pipeline:

```mermaid
graph LR
    A[LLM generates code] --> B[Create sandbox]
    B --> C[Execute in WASM]
    C --> D[Collect metrics]
    D --> E{Success?}
    E -->|Yes| F[Return results]
    E -->|No| G[Send feedback to LLM]
    G --> A
```

### Example Integration

```python
from sandbox import create_sandbox, ExecutionPolicy, RuntimeType

def execute_llm_code(llm_generated_code: str) -> dict:
    """Execute LLM-generated code with safety boundaries."""
    
    # Configure conservative limits for LLM code
    policy = ExecutionPolicy(
        fuel_budget=500_000_000,      # Fail fast on complex code
        memory_bytes=32 * 1024 * 1024,  # 32 MB limit
        stdout_max_bytes=100_000        # 100 KB output
    )
    
    sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
    result = sandbox.execute(llm_generated_code)
    
    # Provide structured feedback for LLM
    if not result.success:
        return {
            "status": "error",
            "feedback": f"Execution failed: {result.stderr}",
            "suggestion": "Simplify the code and avoid complex operations"
        }
    
    if result.fuel_consumed > 400_000_000:
        return {
            "status": "warning",
            "feedback": "Code complexity too high",
            "fuel_used": result.fuel_consumed,
            "suggestion": "Optimize algorithm for better efficiency"
        }
    
    return {
        "status": "success",
        "output": result.stdout,
        "metrics": {
            "fuel": result.fuel_consumed,
            "duration": result.duration_seconds,
            "memory_pages": result.mem_pages
        }
    }

# Use in LLM loop
code = generate_code_from_llm("Calculate fibonacci(10)")
feedback = execute_llm_code(code)
print(feedback)
```

### Multi-Turn Sessions

For stateful LLM interactions with file persistence:

```python
from sandbox import create_sandbox, RuntimeType

# Turn 1: LLM creates data file
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
session_id = sandbox.session_id

result1 = sandbox.execute("""
import json
data = {"users": ["Alice", "Bob"], "count": 2}
with open('/app/data.json', 'w') as f:
    json.dump(data, f)
print("Data saved")
""")

# Turn 2: LLM reads and processes data (same session)
sandbox = create_sandbox(session_id=session_id, runtime=RuntimeType.PYTHON)

result2 = sandbox.execute("""
import json
with open('/app/data.json', 'r') as f:
    data = json.load(f)
data['users'].append('Charlie')
data['count'] = len(data['users'])
print(f"Updated: {data}")
""")

print(result2.stdout)  # "Updated: {'users': ['Alice', 'Bob', 'Charlie'], 'count': 3}"
```

Session workspaces are canonicalized before creation (no `/`, `\\`, or `..` in
IDs) and you can enforce UUID-only IDs via `allow_non_uuid=False`. Vendored
packages are copied per-session so one guest cannot poison another, optional
`mount_data_dir` mounts are read-only, and host-side logs are cleaned up unless
you opt in with `ExecutionPolicy(preserve_logs=True)`.

### Session Management API

Direct session file operations and pruning:

```python
from sandbox import (
    create_sandbox, RuntimeType,
    write_session_file, read_session_file, list_session_files,
    prune_sessions, delete_session_workspace
)

# Create sandbox and write files
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
write_session_file(sandbox.session_id, "data.json", '{"key": "value"}')

# List all files in session
files = list_session_files(sandbox.session_id)
print(files)  # ['data.json', 'user_code.py']

# Read file content
content = read_session_file(sandbox.session_id, "data.json")

# Prune old sessions (e.g., older than 7 days)
result = prune_sessions(max_age_days=7)
print(f"Deleted {result.deleted_count} sessions, freed {result.bytes_freed} bytes")

# Delete specific session
delete_session_workspace(sandbox.session_id)
```

### Pluggable Storage Adapters

Customize storage backend for sessions:

```python
from sandbox import create_sandbox, RuntimeType, StorageAdapter
from pathlib import Path

class CustomStorage(StorageAdapter):
    """Custom storage backend (e.g., S3, Azure Blob)."""
    
    def read(self, path: Path) -> bytes:
        # Implement custom read logic
        pass
    
    def write(self, path: Path, content: bytes) -> None:
        # Implement custom write logic
        pass
    
    def delete(self, path: Path) -> None:
        # Implement custom delete logic
        pass
    
    def exists(self, path: Path) -> bool:
        # Implement custom exists check
        pass

# Use custom storage
storage = CustomStorage()
sandbox = create_sandbox(
    runtime=RuntimeType.PYTHON,
    storage_adapter=storage
)
```

---

## ğŸ”’ Security Model

### Multi-Layered Defense

This sandbox implements defense-in-depth with multiple security boundaries:

#### 1. **WASM Memory Safety**
- Bounds-checked linear memory (no buffer overflows)
- Validated control flow (no arbitrary jumps)
- Type-safe execution (strong typing enforced)

#### 2. **WASI Capability-Based I/O**
- **Preopens only**: File access limited to explicitly granted directories
- **No path traversal**: `..` and absolute paths outside capabilities are denied
- **Descriptor-based**: All I/O goes through validated capability descriptors

#### 3. **Deterministic Execution Limits**
- **Fuel metering**: Instruction-count budgets enforce hard time limits
- **OutOfFuel trap**: Exhausted budget triggers immediate termination
- **No runaway loops**: Infinite loops hit fuel limit automatically

#### 4. **Resource Caps**
- **Memory limit**: WASM linear memory capped at configured size
- **Output limits**: Stdout/stderr truncated to prevent DoS
- **No networking**: Zero network capabilities (no sockets)
- **No subprocesses**: Cannot spawn child processes

### Security Boundaries

| Boundary | Mechanism | Protection |
|----------|-----------|------------|
| **Memory** | WASM bounds checking | Prevents buffer overflows, use-after-free |
| **Filesystem** | WASI preopens | Restricts access to mounted directories only |
| **CPU** | Fuel metering | Prevents infinite loops, excessive computation |
| **I/O** | Capability descriptors | No ambient authority, explicit grants |
| **Environment** | Variable whitelist | Prevents info leaks, credentials exposure |

### Production Hardening

For production deployments, combine with OS-level security:

```python
import subprocess
import signal
from pathlib import Path

def execute_with_timeout(code: str, timeout_seconds: int = 30):
    """Execute sandbox in separate process with OS timeout."""
    
    script = f"""
from sandbox import create_sandbox, RuntimeType
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
result = sandbox.execute({code!r})
print(result.stdout)
"""
    
    try:
        result = subprocess.run(
            ["python", "-c", script],
            timeout=timeout_seconds,
            capture_output=True,
            text=True
        )
        return result.stdout
    except subprocess.TimeoutExpired:
        return "Execution timeout (OS limit)"
```

### Additional Recommendations

- ğŸ³ **Containers**: Run sandbox in Docker/Podman for additional isolation
- ğŸ“¦ **cgroups**: Use Linux cgroups for CPU/memory limits
- ğŸ“Š **Monitoring**: Log all executions with code hashes for audit trails
- â±ï¸ **OS Timeouts**: Combine fuel limits with OS-level process timeouts
- ğŸ” **Network Isolation**: Deploy in network-restricted environments

---

## ğŸ”§ Troubleshooting

### Common Issues

<details>
<summary><b>ğŸš¨ <code>python.wasm not found</code></b></summary>

**Solution:** Download the WASM binary
```powershell
.\scripts\fetch_wlr_python.ps1
```

**Verify:** Check that `bin/python.wasm` exists and is ~50-100 MB

</details>

<details>
<summary><b>ğŸš¨ <code>ImportError: wasmtime could not be imported</code></b></summary>

**Solution:** Install dependencies
```powershell
uv sync
# OR
pip install -r requirements.txt
```

**Verify:** `python -c "import wasmtime; print(wasmtime.__version__)"`

</details>

<details>
<summary><b>ğŸš¨ <code>OutOfFuel</code> trap during execution</b></summary>

**Cause:** Code exceeded instruction budget

**Solution:** Increase fuel budget or simplify code
```python
policy = ExecutionPolicy(fuel_budget=5_000_000_000)  # Increase limit
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
```

</details>

<details>
<summary><b>ğŸš¨ Memory limit errors</b></summary>

**Cause:** WASM memory cap exceeded

**Solution:** Increase memory limit
```python
policy = ExecutionPolicy(memory_bytes=256 * 1024 * 1024)  # 256 MB
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)
```

</details>

<details>
<summary><b>ğŸš¨ <code>FileNotFoundError</code> in guest code</b></summary>

**Cause:** Path outside preopened directories

**Solution:** Use `/app` prefix for all file operations
```python
# âŒ Wrong
open('data.txt', 'r')

# âœ… Correct
open('/app/data.txt', 'r')
```

</details>

<details>
<summary><b>ğŸš¨ <code>ModuleNotFoundError</code> for package</b></summary>

**Cause:** Package not vendored or not in sys.path

**Solution:** Vendor pure-Python package
```powershell
uv run python scripts/manage_vendor.py install <package-name>
uv run python scripts/manage_vendor.py copy
```

Then in sandboxed code:
```python
import sys
sys.path.insert(0, '/app/site-packages')
import <package-name>
```

</details>

### Getting Help

- ğŸ **Report bugs**: [GitHub Issues](https://github.com/yourusername/llm-wasm-sandbox/issues)
- ğŸ“– **Documentation**: See inline code comments and docstrings
- ğŸ’¡ **Examples**: Check `demo*.py` files and `tests/` directory

---

## ğŸ› ï¸ Development

### Running Tests

```powershell
# Run all tests with coverage
uv run pytest tests/ -v --cov=sandbox --cov-report=html

# Run specific test file
uv run pytest tests/test_python_sandbox.py -v

# Run tests matching pattern
uv run pytest tests/ -k "session" -v
```

### Code Quality

```powershell
# Type checking
uv run mypy sandbox/

# Linting and formatting
uv run ruff check sandbox/
uv run ruff format sandbox/
```

### Benchmarking

```powershell
# Performance benchmarks
uv run python benchmark_performance.py

# Session performance
uv run python benchmark_session_performance.py
```

---

## ğŸ¤ Contributing

Contributions are welcome! Please follow these guidelines:

1. **Fork** the repository
2. **Create** a feature branch (`git checkout -b feature/amazing-feature`)
3. **Commit** your changes (`git commit -m 'Add amazing feature'`)
4. **Push** to the branch (`git push origin feature/amazing-feature`)
5. **Open** a Pull Request

### Development Setup

```powershell
# Clone your fork
git clone https://github.com/YOUR-USERNAME/llm-wasm-sandbox.git
cd llm-wasm-sandbox

# Install dev dependencies
uv sync

# Fetch WASM binaries
.\scripts\fetch_wlr_python.ps1
.\scripts\fetch_quickjs.ps1

# Run tests to verify setup
uv run pytest tests/ -v
```

---

## ğŸ“ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## ğŸ”— References & Resources

- **Wasmtime Security**: https://docs.wasmtime.dev/security.html
- **WASI Capabilities**: https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-capabilities.md
- **WebAssembly Language Runtimes**: https://github.com/webassemblylabs/webassembly-language-runtimes
- **Wasmtime Python Bindings**: https://github.com/bytecodealliance/wasmtime-py
- **WASI Specification**: https://github.com/WebAssembly/WASI

---

## ğŸš€ Roadmap

- [x] JavaScript runtime support (QuickJS WASM)
- [x] Pluggable storage adapter interface
- [x] Session pruning and lifecycle management
- [ ] Improved async execution support
- [ ] Network sandboxing with explicit socket grants
- [ ] Enhanced metrics and profiling
- [ ] Web-based demo interface
- [ ] Additional runtime support (Ruby, Lua)

---

## â­ Star History

If you find this project useful, please consider giving it a star on GitHub!

---

<div align="center">

**Built with â¤ï¸ for secure LLM code execution**

[Report Bug](https://github.com/yourusername/llm-wasm-sandbox/issues) â€¢
[Request Feature](https://github.com/yourusername/llm-wasm-sandbox/issues) â€¢
[Documentation](https://github.com/yourusername/llm-wasm-sandbox)

</div>
