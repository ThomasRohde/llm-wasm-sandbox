# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

LLM WASM Sandbox is a production-grade security sandbox for executing untrusted Python and JavaScript code generated by LLMs using WebAssembly (WASM) and WASI. The project uses Wasmtime (Python host) to run CPython WASM and QuickJS WASM with multi-layered security: WASM memory safety, WASI capability-based I/O, deterministic fuel limits, and memory caps.

## Commands

### Setup & Development

```powershell
# Install dependencies (creates virtual environment automatically)
uv sync

# Fetch WASM runtimes (required for development - NOT needed for PyPI installs)
.\scripts\fetch_wlr_python.ps1   # CPython WASM binary (~26 MB)
.\scripts\fetch_quickjs.ps1       # QuickJS WASM binary (~1.4 MB)

# Run examples
uv run python examples/demo.py                         # Python demo
uv run python examples/demo_javascript.py              # JavaScript demo
uv run python examples/demo_session_workflow.py        # Session workflow
```

### Testing

```powershell
# Run all tests with coverage
uv run pytest tests/ -v --cov=sandbox --cov-report=html

# Run specific test file
uv run pytest tests/test_python_sandbox.py -v

# Run tests matching pattern
uv run pytest tests/ -k "session" -v

# Run specific test categories
uv run pytest tests/test_javascript_integration.py -v    # JavaScript runtime tests
uv run pytest tests/test_mcp_integration.py -v           # MCP server tests
uv run pytest tests/test_session_security.py -v          # Security tests
```

### Code Quality

```powershell
# Type checking (strict mode enabled)
uv run mypy sandbox/

# Linting and formatting
uv run ruff check sandbox/
uv run ruff format sandbox/

# Fix auto-fixable issues
uv run ruff check --fix sandbox/
```

### MCP Server

```powershell
# Run MCP server for development
.\scripts\run-mcp-dev.ps1

# Or using the package directly
uv run python -m mcp_server

# Or using example scripts
uv run python examples/llm_wasm_mcp.py              # Promiscuous mode
uv run python examples/mcp_stdio_example.py         # With security filters
```

### Package Management

```powershell
# Vendor a new pure-Python package
uv run python scripts/manage_vendor.py install <package-name>
uv run python scripts/manage_vendor.py copy

# Publishing (maintainers only)
.\scripts\publish.ps1
```

## Architecture

### Three-Layer Structure

**1. Core Layer** (`sandbox/core/`)
- Type-safe foundation with Pydantic models
- `models.py`: ExecutionPolicy, SandboxResult, RuntimeType
- `base.py`: BaseSandbox abstract interface
- `errors.py`: PolicyValidationError, SandboxExecutionError
- `logging.py`: Structured event logging
- `factory.py`: create_sandbox() factory function
- `storage.py`: Pluggable storage adapter interface

**2. Runtime Layer** (`sandbox/runtimes/`)
- Runtime-specific sandbox implementations
- `python/sandbox.py`: PythonSandbox - CPython WASM execution
- `javascript/sandbox.py`: JavaScriptSandbox - QuickJS WASM execution
- Both support automatic state persistence via `auto_persist_globals`

**3. Host Layer** (`sandbox/host.py`)
- Low-level Wasmtime/WASI configuration
- WASM binary loading and execution
- Fuel budgeting and memory limiting
- Capability-based filesystem isolation (WASI preopens)

### Key Components

**Session Management** (`sandbox/sessions.py`)
- UUID-based session IDs with workspace isolation
- Session file operations (read/write/list/delete)
- Automatic pruning of old sessions with configurable retention
- Workspace path validation and canonicalization

**State Persistence** (`sandbox/state.py`, `sandbox/state_js.py`)
- Automatic global variable persistence for Python and JavaScript
- Serialization filtering (excludes modules, functions, classes)
- JSON-based state storage in session workspace
- State helpers injected at runtime for load/save operations

**MCP Integration** (`mcp_server/`)
- Model Context Protocol server for standardized LLM tool use
- Session manager with automatic workspace isolation
- Security validation and rate limiting
- Stdio and HTTP transports for different deployment scenarios

**Policy Configuration** (`config/policy.toml`)
- Centralized execution limits configuration
- Default fuel budget: 5B instructions (supports heavy imports like openpyxl, jinja2)
- Memory limit: 128 MB
- Output caps: 2 MB stdout, 1 MB stderr
- WASI preopens and environment variable whitelist

### Security Boundaries

| Layer | Mechanism | Purpose |
|-------|-----------|---------|
| **WASM Memory** | Bounds checking | Prevents buffer overflows, use-after-free |
| **Filesystem** | WASI preopens | Restricts access to `/app` only (workspace) |
| **CPU** | Fuel metering | Prevents infinite loops, limits computation |
| **Memory** | Linear memory cap | Prevents memory exhaustion |
| **Environment** | Variable whitelist | Prevents info leaks, credential exposure |

## Code Conventions

### Type Safety
- Python 3.11+ required (uses `tomllib` for TOML parsing)
- All functions must have type hints (enforced by mypy)
- Use `from __future__ import annotations` for forward references
- Pydantic models for configuration and results (validated at runtime)

### Error Handling
- Catch `wasmtime.Trap` for fuel exhaustion and WASM errors
- Use specific exceptions (PolicyValidationError, SandboxExecutionError)
- Malicious code failures are expected - capture in stderr, don't re-raise
- Structured error guidance in `result.metadata["error_guidance"]`

### Fuel Analysis
- All execution results include fuel analysis in `result.metadata["fuel_analysis"]`
- Status levels: efficient (0-50%), moderate (50-75%), warning (75-90%), critical (90-100%)
- Automatic budget recommendations for similar workloads
- Heavy imports (openpyxl, jinja2, PyPDF2) require 5B+ fuel budget

### Session Management
- All sandboxes are session-aware with auto-generated UUIDs
- Session IDs are canonicalized (no `/`, `\\`, or `..` allowed)
- Use `allow_non_uuid=False` to enforce strict UUID validation
- Workspace directory: `workspace/<session-id>/` (writable as `/app` in guest)
- Vendored packages: `/data/site-packages` (read-only, shared across sessions)

### State Persistence
- Use `auto_persist_globals=True` for automatic variable persistence
- State saved/loaded between executions in same session
- Filters out non-serializable objects (modules, functions, classes)
- Python: JSON-based serialization
- JavaScript: JSON.stringify/parse with state helpers

## Windows-Specific Notes

### PowerShell Command Execution

**CRITICAL**: PowerShell has complex quoting rules. When executing Python code with nested quotes:

**✅ CORRECT**: Create a temporary .py file for complex code
```powershell
@'
from sandbox import create_sandbox, RuntimeType
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)
result = sandbox.execute('print("hello")')
print(result.stdout)
'@ | Out-File -FilePath temp_test.py -Encoding utf8
uv run python temp_test.py
Remove-Item temp_test.py
```

**✅ CORRECT**: Use triple-quoted strings for embedded code
```powershell
uv run python -c "from sandbox import create_sandbox; code = '''print(\"hello\")'''; print(create_sandbox().execute(code).stdout)"
```

**❌ NEVER**: Pass complex Python code with nested quotes directly
```powershell
# FAILS: Unterminated string literal
uv run python -c "from sandbox import create_sandbox; result = sandbox.execute('print(\"hello\")')"
```

### Path Handling
- Use `pathlib.Path` objects for cross-platform compatibility
- Workspace paths are automatically converted to Windows format
- Scripts use PowerShell (`.ps1`) by default on Windows

## Important Patterns

### Creating a Sandbox

```python
from sandbox import create_sandbox, ExecutionPolicy, RuntimeType

# Python runtime (default)
sandbox = create_sandbox(runtime=RuntimeType.PYTHON)

# JavaScript runtime
sandbox = create_sandbox(runtime=RuntimeType.JAVASCRIPT)

# With custom policy
policy = ExecutionPolicy(
    fuel_budget=5_000_000_000,      # 5B for heavy imports
    memory_bytes=128_000_000         # 128 MB
)
sandbox = create_sandbox(runtime=RuntimeType.PYTHON, policy=policy)

# With automatic state persistence (recommended for multi-turn LLM workflows)
sandbox = create_sandbox(
    runtime=RuntimeType.PYTHON,
    auto_persist_globals=True        # Variables persist across executions
)

# Resume existing session
sandbox = create_sandbox(
    session_id='550e8400-e29b-41d4-a716-446655440000',
    runtime=RuntimeType.PYTHON
)
```

### Execution Result Handling

```python
result = sandbox.execute(code)

# Check success
if not result.success:
    print(f"Error: {result.stderr}")
    
    # Get structured error guidance
    guidance = result.metadata.get("error_guidance", {})
    print(f"Error type: {guidance.get('error_type')}")
    for solution in guidance.get("actionable_guidance", []):
        print(f"Solution: {solution}")

# Check fuel usage
fuel_analysis = result.metadata.get("fuel_analysis", {})
if fuel_analysis.get("status") in ("warning", "critical"):
    print(f"Warning: {fuel_analysis.get('recommendation')}")
    print(f"Suggested budget: {fuel_analysis.get('suggested_budget')}")

# Access outputs
print(result.stdout)
print(f"Fuel consumed: {result.fuel_consumed}")
print(f"Duration: {result.duration_seconds}s")
```

### Session File Operations

```python
from sandbox import (
    write_session_file,
    read_session_file,
    list_session_files,
    delete_session_workspace
)

# Write file to session
write_session_file(session_id, "data.json", '{"key": "value"}')

# Read file from session
content = read_session_file(session_id, "data.json")

# List files in session
files = list_session_files(session_id)

# Clean up session
delete_session_workspace(session_id)
```

### Session Pruning

```python
from sandbox import prune_sessions

# Prune sessions older than 7 days
result = prune_sessions(max_age_days=7)
print(f"Deleted {result.deleted_count} sessions")
print(f"Freed {result.bytes_freed} bytes")
```

## Known Limitations

- **Blocking host calls**: Fuel can't interrupt sleep/blocking I/O - requires OS-level timeout wrapper
- **No async support**: Current wasmtime-py lacks async WASI bindings
- **Single-threaded**: WASM guest is single-threaded (CPython GIL doesn't matter here)
- **No networking**: By design - baseline WASI doesn't expose sockets
- **Pure-Python packages only**: Vendored packages with C/Rust extensions will fail in WASM
- **File paths**: All file operations must use `/app/` prefix (guest mount point for workspace)

## Security Considerations

When modifying this codebase:

1. **Never expand WASI capabilities** without explicit security review (e.g., adding network access)
2. **Validate policy changes**: Lowering limits may break use cases; increasing may enable DoS
3. **Preopen paths must be absolute**: Relative paths can leak host info via error messages
4. **Environment variable whitelist**: Only expose explicitly required vars (no `os.environ` passthrough)
5. **Test malicious inputs**: Any new feature must have corresponding security tests
6. **Fuel budgets**: Always test with realistic workloads - heavy imports can exceed default budgets

## Testing Guidelines

- All test files follow pattern `test_*.py` in `tests/` directory
- Use pytest fixtures from `tests/conftest.py` for common setup
- Security tests verify isolation boundaries (filesystem, memory, CPU)
- Integration tests verify multi-turn sessions and state persistence
- MCP tests verify tool behavior and session management
- Type tests verify Pydantic model validation

## External Dependencies

- **Wasmtime**: Pin to `wasmtime>=38.0.0,<39.0.0` (API changes frequently)
- **WLR Python binary**: Update `scripts/fetch_wlr_python.ps1` for new releases
- **QuickJS binary**: Update `scripts/fetch_quickjs.ps1` for new releases
- **Pydantic**: `pydantic>=2.0.0,<3.0.0` for type-safe models
- **FastMCP**: `fastmcp>=2.13.1` for MCP server implementation
